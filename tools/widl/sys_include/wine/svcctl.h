/*** Autogenerated by WIDL 1.1.6 from wine/svcctl.idl - Do not edit ***/
#include <rpc.h>
#include <rpcndr.h>

#ifndef __WIDL_SVCCTL_H
#define __WIDL_SVCCTL_H
#ifdef __cplusplus
extern "C" {
#endif

#include <wtypes.h>
#include "winsvc.h"
#define SVCCTL_TRANSPORT {'n','c','a','c','n','_','n','p',0}
#define SVCCTL_ENDPOINT {'\\','p','i','p','e','\\','s','v','c','c','t','l',0}
#define SVCCTL_STARTED_EVENT {'_','_','w','i','n','e','_','S','v','c','c','t','l','S','t','a','r','t','e','d',0}
enum service_pipe_command {
    WINESERV_STARTINFO = 1,
    WINESERV_SENDCONTROL = 2
};

typedef struct service_start_info_t {
    enum service_pipe_command cmd;
    DWORD total_size;
    DWORD name_size;
    DWORD control;
    WCHAR data[1];
} service_start_info;
typedef LPCWSTR MACHINE_HANDLEW;
typedef void *SC_RPC_HANDLE;
typedef void *SC_RPC_LOCK;
#define SERVICE_SET_STATUS   0x8000
#if 0 /* already defined in winsvc.h */
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPWSTR lpBinaryPathName;
    LPWSTR lpLoadOrderGroup;
    DWORD dwTagId;
    LPWSTR lpDependencies;
    LPWSTR lpServiceStartName;
    LPWSTR lpDisplayName;
} QUERY_SERVICE_CONFIGW;
typedef struct _QUERY_SERVICE_CONFIGW *LPQUERY_SERVICE_CONFIGW;
typedef struct _SERVICE_STATUS {
    DWORD dwServiceType;
    DWORD dwCurrentState;
    DWORD dwControlsAccepted;
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
} SERVICE_STATUS;
typedef struct _SERVICE_STATUS *LPSERVICE_STATUS;
typedef enum _SC_STATUS_TYPE {
    SC_STATUS_PROCESS_INFO = 0
} SC_STATUS_TYPE;
#endif
void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free(void *);

/*****************************************************************************
 * svcctl interface (v2.0)
 */
#ifndef __svcctl_INTERFACE_DEFINED__
#define __svcctl_INTERFACE_DEFINED__

extern RPC_IF_HANDLE svcctl_v2_0_c_ifspec;
extern RPC_IF_HANDLE svcctl_v2_0_s_ifspec;
DWORD svcctl_CloseServiceHandle(
    SC_RPC_HANDLE *handle);

DWORD svcctl_ControlService(
    SC_RPC_HANDLE hService,
    DWORD dwControl,
    SERVICE_STATUS *lpServiceStatus);

DWORD svcctl_DeleteService(
    SC_RPC_HANDLE hService);

DWORD svcctl_LockServiceDatabase(
    SC_RPC_HANDLE hSCManager,
    SC_RPC_LOCK *phLock);

DWORD svcctl_QueryServiceObjectSecurity(
    void);

DWORD svcctl_SetServiceObjectSecurity(
    void);

DWORD svcctl_QueryServiceStatus(
    void);

DWORD svcctl_SetServiceStatus(
    SC_RPC_HANDLE hServiceStatus,
    LPSERVICE_STATUS lpServiceStatus);

DWORD svcctl_UnlockServiceDatabase(
    SC_RPC_LOCK *phLock);

DWORD svcctl_NotifyBootConfigStatus(
    void);

DWORD svcctl_SCSetServiceBitsW(
    void);

DWORD svcctl_ChangeServiceConfigW(
    SC_RPC_HANDLE hService,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCWSTR lpBinaryPathName,
    LPCWSTR lpLoadOrderGroupKey,
    DWORD *lpdwTagId,
    const BYTE *lpDependencies,
    DWORD dwDependenciesSize,
    LPCWSTR lpServiceStartName,
    const BYTE *lpPassword,
    DWORD dwPasswordSize,
    LPCWSTR lpDisplayName);

DWORD svcctl_CreateServiceW(
    SC_RPC_HANDLE hSCManager,
    LPCWSTR lpServiceName,
    LPCWSTR lpDisplayName,
    DWORD dwDesiredAccess,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCWSTR lpBinaryPathName,
    LPCWSTR lpLoadOrderGroup,
    DWORD *lpdwTagId,
    const BYTE *lpDependencies,
    DWORD dwDependenciesSize,
    LPCWSTR lpServiceStartName,
    const BYTE *lpPassword,
    DWORD dwPasswordSize,
    SC_RPC_HANDLE *phService);

DWORD svcctl_EnumDependentServicesW(
    void);

DWORD svcctl_EnumServicesStatusW(
    void);

DWORD svcctl_OpenSCManagerW(
    MACHINE_HANDLEW MachineName,
    LPCWSTR DatabaseName,
    DWORD dwAccessMask,
    SC_RPC_HANDLE *handle);

DWORD svcctl_OpenServiceW(
    SC_RPC_HANDLE hSCManager,
    LPCWSTR lpServiceName,
    DWORD dwDesiredAccess,
    SC_RPC_HANDLE *phService);

DWORD svcctl_QueryServiceConfigW(
    SC_RPC_HANDLE hService,
    QUERY_SERVICE_CONFIGW *config);

DWORD svcctl_QueryServiceLockStatusW(
    void);

DWORD svcctl_StartServiceW(
    SC_RPC_HANDLE hService,
    DWORD dwNumServiceArgs,
    LPCWSTR *lpServiceArgVectors);

DWORD svcctl_GetServiceDisplayNameW(
    SC_RPC_HANDLE hSCManager,
    LPCWSTR lpServiceName,
    WCHAR lpBuffer[],
    DWORD cchBufSize,
    DWORD *cchLength);

DWORD svcctl_GetServiceKeyNameW(
    SC_RPC_HANDLE hSCManager,
    LPCWSTR lpServiceDisplayName,
    WCHAR lpBuffer[],
    DWORD cchBufSize,
    DWORD *cchLength);

DWORD svcctl_SCSetServiceBitsA(
    void);

DWORD svcctl_ChangeServiceConfigA(
    void);

DWORD svcctl_CreateServiceA(
    void);

DWORD svcctl_EnumDependentServicesA(
    void);

DWORD svcctl_EnumServicesStatusA(
    void);

DWORD svcctl_OpenSCManagerA(
    void);

DWORD svcctl_OpenServiceA(
    void);

DWORD svcctl_QueryServiceConfigA(
    void);

DWORD svcctl_QueryServiceLockStatusA(
    void);

DWORD svcctl_StartServiceA(
    void);

DWORD svcctl_GetServiceDisplayNameA(
    void);

DWORD svcctl_GetServiceKeyNameA(
    void);

DWORD svcctl_GetCurrentGroupStateW(
    void);

DWORD svcctl_EnumServiceGroupW(
    void);

DWORD svcctl_ChangeServiceConfig2A(
    void);

DWORD svcctl_ChangeServiceConfig2W(
    void);

DWORD svcctl_QueryServiceConfig2A(
    void);

DWORD svcctl_QueryServiceConfig2W(
    void);

DWORD svcctl_QueryServiceStatusEx(
    SC_RPC_HANDLE hService,
    SC_STATUS_TYPE InfoLevel,
    BYTE *lpBuffer,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded);


#endif  /* __svcctl_INTERFACE_DEFINED__ */

/* Begin additional prototypes for all interfaces */

handle_t __RPC_USER MACHINE_HANDLEW_bind(MACHINE_HANDLEW);
void __RPC_USER MACHINE_HANDLEW_unbind(MACHINE_HANDLEW, handle_t);
void __RPC_USER SC_RPC_HANDLE_rundown(SC_RPC_HANDLE);
void __RPC_USER SC_RPC_LOCK_rundown(SC_RPC_LOCK);

/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __WIDL_SVCCTL_H */
